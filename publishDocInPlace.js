#!/usr/bin/env node

const cleanBook = require('./cleanMarkdown');
const glob = require('globule');
const gutil = require('gulp-util');
const shell = require('shelljs');
const fs = require('fs');
const chalk = require('chalk');

let currentPath = process.cwd();
/*
This is the script for downloading a doc (or a list of docs) usingf the CLaaT
tool as a Markdown file. It then uses the cleanup() function from the
cleanMarkdown.js file to process the Markdown into a format that works for
publishing on GitBook.
*/
try {
  /*
  Get the doc IDs from the command line arguments. The first two parameters
  of process.argv are the path of your node installation andthe path of this
  script.
  */
  let docIds = process.argv.slice([2]);
  docIds.forEach(function(docId) {
    // For each docId, export the doc in the current directory
    shell.exec(`${__dirname}/claat export  -f md -o "${currentPath}" ${docId}`);

    /*
    Find all the codelab.json files in your directory (this is metadata
    generated by CLaaT).
    */
    let metadataFiles = glob.find(`*/codelab.json`);

    /*
    To find the directory of the exported doc, we need the url, which is
    a unique name that CLaaT uses to create the directory for the Markdown
    file. We can find this in the metadata file, but to find the right one
    we need to iterate over all of them and check that the ID (stored in the
    source field) matches the passed in doc ID.
    */
    metadataFiles.forEach(function(metadataFile) {
      let metadata = fs.readFileSync(metadataFile);
      metadata = JSON.parse(metadata);

      if (docId === metadata.source) {
        // Log the name of the downloaded file
        gutil.log(' ', chalk.cyan('Downloaded'), chalk.cyan(metadata.title));

        // Run the cleanup script on the current doc
        cleanBook.cleanup(`${currentPath}/${metadata.url}/index.md`,
          `${currentPath}/${metadata.url}/index.md`);

        // Log the name of the cleaned file
        gutil.log('  ', chalk.cyan('Cleaned'), chalk.cyan(metadata.title));
      }
    });
  });
} catch (err) {
  console.log(err);
  shell.exit(1);
}
